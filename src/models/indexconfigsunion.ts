/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type IndexConfigsObject = {
  type: "object";
  objectIndexConfigs: { [k: string]: any };
};

export const TypeEnum = {
  Keyword: "keyword",
  Long: "long",
  Double: "double",
  Datetime: "datetime",
  Boolean: "boolean",
  SparseVector: "sparseVector",
} as const;
export type TypeEnum = ClosedEnum<typeof TypeEnum>;

/**
 * Types that do not need additional parameters.
 */
export type IndexConfigs = {
  type: TypeEnum;
};

/**
 * Vector similarity metric.
 */
export const Similarity = {
  Cosine: "cosine",
  Euclidean: "euclidean",
  DotProduct: "dot_product",
  MaxInnerProduct: "max_inner_product",
} as const;
/**
 * Vector similarity metric.
 */
export type Similarity = ClosedEnum<typeof Similarity>;

export type IndexConfigsVector = {
  type: "vector";
  /**
   * Vector dimensions.
   */
  dimensions: number;
  /**
   * Vector similarity metric.
   */
  similarity?: Similarity | undefined;
};

export const Analyzer = {
  Standard: "standard",
  Korean: "korean",
  Japanese: "japanese",
  English: "english",
} as const;
export type Analyzer = ClosedEnum<typeof Analyzer>;

export type IndexConfigsText = {
  type: "text";
  /**
   * Analyzers.
   */
  analyzers?: Array<Analyzer> | undefined;
};

export type IndexConfigsUnion =
  | IndexConfigsText
  | IndexConfigsVector
  | (IndexConfigs & { type: "keyword" })
  | (IndexConfigs & { type: "long" })
  | (IndexConfigs & { type: "double" })
  | (IndexConfigs & { type: "datetime" })
  | (IndexConfigs & { type: "boolean" })
  | (IndexConfigs & { type: "sparseVector" })
  | IndexConfigsObject;

/** @internal */
export const IndexConfigsObject$inboundSchema: z.ZodType<
  IndexConfigsObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("object"),
  objectIndexConfigs: z.record(z.any()),
});
/** @internal */
export type IndexConfigsObject$Outbound = {
  type: "object";
  objectIndexConfigs: { [k: string]: any };
};

/** @internal */
export const IndexConfigsObject$outboundSchema: z.ZodType<
  IndexConfigsObject$Outbound,
  z.ZodTypeDef,
  IndexConfigsObject
> = z.object({
  type: z.literal("object"),
  objectIndexConfigs: z.record(z.any()),
});

export function indexConfigsObjectToJSON(
  indexConfigsObject: IndexConfigsObject,
): string {
  return JSON.stringify(
    IndexConfigsObject$outboundSchema.parse(indexConfigsObject),
  );
}
export function indexConfigsObjectFromJSON(
  jsonString: string,
): SafeParseResult<IndexConfigsObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IndexConfigsObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IndexConfigsObject' from JSON`,
  );
}

/** @internal */
export const TypeEnum$inboundSchema: z.ZodNativeEnum<typeof TypeEnum> = z
  .nativeEnum(TypeEnum);
/** @internal */
export const TypeEnum$outboundSchema: z.ZodNativeEnum<typeof TypeEnum> =
  TypeEnum$inboundSchema;

/** @internal */
export const IndexConfigs$inboundSchema: z.ZodType<
  IndexConfigs,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: TypeEnum$inboundSchema,
});
/** @internal */
export type IndexConfigs$Outbound = {
  type: string;
};

/** @internal */
export const IndexConfigs$outboundSchema: z.ZodType<
  IndexConfigs$Outbound,
  z.ZodTypeDef,
  IndexConfigs
> = z.object({
  type: TypeEnum$outboundSchema,
});

export function indexConfigsToJSON(indexConfigs: IndexConfigs): string {
  return JSON.stringify(IndexConfigs$outboundSchema.parse(indexConfigs));
}
export function indexConfigsFromJSON(
  jsonString: string,
): SafeParseResult<IndexConfigs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IndexConfigs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IndexConfigs' from JSON`,
  );
}

/** @internal */
export const Similarity$inboundSchema: z.ZodNativeEnum<typeof Similarity> = z
  .nativeEnum(Similarity);
/** @internal */
export const Similarity$outboundSchema: z.ZodNativeEnum<typeof Similarity> =
  Similarity$inboundSchema;

/** @internal */
export const IndexConfigsVector$inboundSchema: z.ZodType<
  IndexConfigsVector,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("vector"),
  dimensions: z.number().int(),
  similarity: Similarity$inboundSchema.default("cosine"),
});
/** @internal */
export type IndexConfigsVector$Outbound = {
  type: "vector";
  dimensions: number;
  similarity: string;
};

/** @internal */
export const IndexConfigsVector$outboundSchema: z.ZodType<
  IndexConfigsVector$Outbound,
  z.ZodTypeDef,
  IndexConfigsVector
> = z.object({
  type: z.literal("vector"),
  dimensions: z.number().int(),
  similarity: Similarity$outboundSchema.default("cosine"),
});

export function indexConfigsVectorToJSON(
  indexConfigsVector: IndexConfigsVector,
): string {
  return JSON.stringify(
    IndexConfigsVector$outboundSchema.parse(indexConfigsVector),
  );
}
export function indexConfigsVectorFromJSON(
  jsonString: string,
): SafeParseResult<IndexConfigsVector, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IndexConfigsVector$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IndexConfigsVector' from JSON`,
  );
}

/** @internal */
export const Analyzer$inboundSchema: z.ZodNativeEnum<typeof Analyzer> = z
  .nativeEnum(Analyzer);
/** @internal */
export const Analyzer$outboundSchema: z.ZodNativeEnum<typeof Analyzer> =
  Analyzer$inboundSchema;

/** @internal */
export const IndexConfigsText$inboundSchema: z.ZodType<
  IndexConfigsText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
  analyzers: z.array(Analyzer$inboundSchema).optional(),
});
/** @internal */
export type IndexConfigsText$Outbound = {
  type: "text";
  analyzers?: Array<string> | undefined;
};

/** @internal */
export const IndexConfigsText$outboundSchema: z.ZodType<
  IndexConfigsText$Outbound,
  z.ZodTypeDef,
  IndexConfigsText
> = z.object({
  type: z.literal("text"),
  analyzers: z.array(Analyzer$outboundSchema).optional(),
});

export function indexConfigsTextToJSON(
  indexConfigsText: IndexConfigsText,
): string {
  return JSON.stringify(
    IndexConfigsText$outboundSchema.parse(indexConfigsText),
  );
}
export function indexConfigsTextFromJSON(
  jsonString: string,
): SafeParseResult<IndexConfigsText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IndexConfigsText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IndexConfigsText' from JSON`,
  );
}

/** @internal */
export const IndexConfigsUnion$inboundSchema: z.ZodType<
  IndexConfigsUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => IndexConfigsText$inboundSchema),
  z.lazy(() => IndexConfigsVector$inboundSchema),
  z.lazy(() => IndexConfigs$inboundSchema).and(
    z.object({ type: z.literal("keyword") }),
  ),
  z.lazy(() => IndexConfigs$inboundSchema).and(
    z.object({ type: z.literal("long") }),
  ),
  z.lazy(() => IndexConfigs$inboundSchema).and(
    z.object({ type: z.literal("double") }),
  ),
  z.lazy(() => IndexConfigs$inboundSchema).and(
    z.object({ type: z.literal("datetime") }),
  ),
  z.lazy(() => IndexConfigs$inboundSchema).and(
    z.object({ type: z.literal("boolean") }),
  ),
  z.lazy(() => IndexConfigs$inboundSchema).and(
    z.object({ type: z.literal("sparseVector") }),
  ),
  z.lazy(() => IndexConfigsObject$inboundSchema),
]);
/** @internal */
export type IndexConfigsUnion$Outbound =
  | IndexConfigsText$Outbound
  | IndexConfigsVector$Outbound
  | (IndexConfigs$Outbound & { type: "keyword" })
  | (IndexConfigs$Outbound & { type: "long" })
  | (IndexConfigs$Outbound & { type: "double" })
  | (IndexConfigs$Outbound & { type: "datetime" })
  | (IndexConfigs$Outbound & { type: "boolean" })
  | (IndexConfigs$Outbound & { type: "sparseVector" })
  | IndexConfigsObject$Outbound;

/** @internal */
export const IndexConfigsUnion$outboundSchema: z.ZodType<
  IndexConfigsUnion$Outbound,
  z.ZodTypeDef,
  IndexConfigsUnion
> = z.union([
  z.lazy(() => IndexConfigsText$outboundSchema),
  z.lazy(() => IndexConfigsVector$outboundSchema),
  z.lazy(() => IndexConfigs$outboundSchema).and(
    z.object({ type: z.literal("keyword") }),
  ),
  z.lazy(() => IndexConfigs$outboundSchema).and(
    z.object({ type: z.literal("long") }),
  ),
  z.lazy(() => IndexConfigs$outboundSchema).and(
    z.object({ type: z.literal("double") }),
  ),
  z.lazy(() => IndexConfigs$outboundSchema).and(
    z.object({ type: z.literal("datetime") }),
  ),
  z.lazy(() => IndexConfigs$outboundSchema).and(
    z.object({ type: z.literal("boolean") }),
  ),
  z.lazy(() => IndexConfigs$outboundSchema).and(
    z.object({ type: z.literal("sparseVector") }),
  ),
  z.lazy(() => IndexConfigsObject$outboundSchema),
]);

export function indexConfigsUnionToJSON(
  indexConfigsUnion: IndexConfigsUnion,
): string {
  return JSON.stringify(
    IndexConfigsUnion$outboundSchema.parse(indexConfigsUnion),
  );
}
export function indexConfigsUnionFromJSON(
  jsonString: string,
): SafeParseResult<IndexConfigsUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IndexConfigsUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IndexConfigsUnion' from JSON`,
  );
}
