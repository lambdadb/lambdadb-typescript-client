/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export type QueryCollectionRequestBody = {
  /**
   * Number of documents to return. Note that the maximum number of documents is 100.
   */
  size?: number | undefined;
  /**
   * Query object.
   */
  query: { [k: string]: any };
  /**
   * If your application requires a strongly consistent read, set consistentRead to true. Although a strongly consistent read might take more time than an eventually consistent read, it always returns the last updated value.
   */
  consistentRead?: boolean | undefined;
  /**
   * If your application need to include vector values in the response, set includeVectors to true.
   */
  includeVectors?: boolean | undefined;
  /**
   * List of field name, sort direction pairs.
   */
  sort?: Array<{ [k: string]: any }> | undefined;
  /**
   * An object to specify a list of field names to include and/or exclude in the result.
   */
  fields?: models.FieldsSelectorUnion | undefined;
  partitionFilter?: models.PartitionFilter | undefined;
};

export type QueryCollectionRequest = {
  /**
   * Collection name.
   */
  collectionName: string;
  requestBody: QueryCollectionRequestBody;
};

export type QueryCollectionDoc = {
  /**
   * Collection name.
   */
  collection: string;
  /**
   * Document similarity score.
   */
  score?: number | undefined;
  doc: { [k: string]: any };
};

/**
 * Documents selected by query.
 */
export type QueryCollectionResponse = {
  /**
   * Elapsed time in milliseconds.
   */
  took: number;
  /**
   * Maximum score.
   */
  maxScore?: number | undefined;
  /**
   * Total number of documents returned.
   */
  total: number;
  /**
   * List of documents.
   */
  docs: Array<QueryCollectionDoc>;
};

/** @internal */
export type QueryCollectionRequestBody$Outbound = {
  size?: number | undefined;
  query: { [k: string]: any };
  consistentRead: boolean;
  includeVectors: boolean;
  sort?: Array<{ [k: string]: any }> | undefined;
  fields?: models.FieldsSelectorUnion$Outbound | undefined;
  partitionFilter?: models.PartitionFilter$Outbound | undefined;
};

/** @internal */
export const QueryCollectionRequestBody$outboundSchema: z.ZodType<
  QueryCollectionRequestBody$Outbound,
  z.ZodTypeDef,
  QueryCollectionRequestBody
> = z.object({
  size: z.number().int().optional(),
  query: z.record(z.any()),
  consistentRead: z.boolean().default(false),
  includeVectors: z.boolean().default(false),
  sort: z.array(z.record(z.any())).optional(),
  fields: models.FieldsSelectorUnion$outboundSchema.optional(),
  partitionFilter: models.PartitionFilter$outboundSchema.optional(),
});

export function queryCollectionRequestBodyToJSON(
  queryCollectionRequestBody: QueryCollectionRequestBody,
): string {
  return JSON.stringify(
    QueryCollectionRequestBody$outboundSchema.parse(queryCollectionRequestBody),
  );
}

/** @internal */
export type QueryCollectionRequest$Outbound = {
  collectionName: string;
  RequestBody: QueryCollectionRequestBody$Outbound;
};

/** @internal */
export const QueryCollectionRequest$outboundSchema: z.ZodType<
  QueryCollectionRequest$Outbound,
  z.ZodTypeDef,
  QueryCollectionRequest
> = z.object({
  collectionName: z.string(),
  requestBody: z.lazy(() => QueryCollectionRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function queryCollectionRequestToJSON(
  queryCollectionRequest: QueryCollectionRequest,
): string {
  return JSON.stringify(
    QueryCollectionRequest$outboundSchema.parse(queryCollectionRequest),
  );
}

/** @internal */
export const QueryCollectionDoc$inboundSchema: z.ZodType<
  QueryCollectionDoc,
  z.ZodTypeDef,
  unknown
> = z.object({
  collection: z.string(),
  score: z.number().optional(),
  doc: z.record(z.any()),
});

export function queryCollectionDocFromJSON(
  jsonString: string,
): SafeParseResult<QueryCollectionDoc, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QueryCollectionDoc$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QueryCollectionDoc' from JSON`,
  );
}

/** @internal */
export const QueryCollectionResponse$inboundSchema: z.ZodType<
  QueryCollectionResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  took: z.number().int(),
  maxScore: z.number().optional(),
  total: z.number().int(),
  docs: z.array(z.lazy(() => QueryCollectionDoc$inboundSchema)),
});

export function queryCollectionResponseFromJSON(
  jsonString: string,
): SafeParseResult<QueryCollectionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QueryCollectionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QueryCollectionResponse' from JSON`,
  );
}
